---
title: "LMTP_Heterogeneous"
output: html_document
---

```{r}
devtools::load_all(".")
# library(modulatR)

set.seed(2025)
library(simcausal)
library(TargetedLearning)
library(dplyr)

# n: sample size
n <- 1000

# ---- DAG specification in simcausal ----
D <- DAG.empty()

# Baseline covariates
D <- D +
  node("W1", distr = "rnorm", mean = 0, sd = 1) +
  node("W2", distr = "rbern", prob = 0.5)  # will use this to define V

# Two time-varying covariates at each t = 1,2,3
D <- D +
  node("L1", t = 1:3, distr = "rnorm",
       mean =  0.8*W1 + 0.5*W2 + 0.2*t, sd = 1) +
  node("L2", t = 1:3, distr = "rnorm",
       mean = -0.3*W1 + 0.7*W2 - 0.1*t, sd = 1)

# Exposures at t = 1,2,3 (continuous)
D <- D +
  node("A", t = 1:3, distr = "rnorm",
       mean = 0.4*W1 + 0.2*W2,
       sd = 1)

# Make the effect of A on Y depend on W2 (and hence V)
# For W2 = 0 (V = 1): effect = 0.2 * (A1 + A2 + A3)
# For W2 = 1 (V = 2): effect = 0.5 * (A1 + A2 + A3)
D <- D +
  node("Y", distr = "rnorm",
       mean =
         (0.2 + 0.3*W2) * (A[1] + A[2] + A[3]) +
         0.3*W1 + 0.1*W2,
       sd = 1, t = 4)

# Finalize and simulate
Dset <- set.DAG(D)
raw <- sim(Dset, n = n)

# ---- Post-process to your exact column names ----
df <- raw %>%
  transmute(
    id = seq_len(n),
    W1 = W1,
    W2 = W2,
    # define V ∈ {1,2} as a function of W2
    V  = W2 + 1L,
    L11 = L1_1, L12 = L2_1,
    L21 = L1_2, L22 = L2_2,
    L31 = L1_3, L32 = L2_3,
    A1  = A_1,  A2  = A_2,  A3  = A_3,
    Y = Y_4
  )

table(df$V)
# V=1 corresponds to W2=0, smaller A→Y effect
# V=2 corresponds to W2=1, larger A→Y effect

# ---- LMTP data structure ----
ds <- LMTP_Data_Struct$new(
  data = df, id_col = "id", n_timesteps = 3,
  A_cols = c("A1","A2","A3"),
  L_cols = list(c("L11","L12"), c("L21","L22"), c("L31","L32")),
  W_cols = c("W1","V"),  # V is included in W
  Y_col = "Y"
)

# ---- LMTP policies ----

# policy: small negative shift in A at each time
shift_mtp <- mtp_additive_shift(delta = -0.05)
policy_seq <- repeat_policy_over_time(shift_mtp, 3)

# identity policy (no intervention) for sanity checks if needed
identity_mtp <- mtp_additive_shift(delta = 0)
policy_seq_identity <- repeat_policy_over_time(identity_mtp, 3)

# ---- Nuisance factories ----
# density-based version (simpler to reason about)
nuis_density <- LMTPNuisanceFactory$new(
  learners_g = nadir::lnr_lm_density,
  policy_seq = policy_seq,
  A_type = "continuous",
  repeat_fmls_lnrs_args = TRUE,
  g_mode = "density"
)

# ratio-classification version (optional)
nuis_ratio <- LMTPNuisanceFactory$new(
  learners_g = list(nadir::lnr_logistic, nadir::lnr_rf_binary),
  policy_seq = policy_seq,
  A_type = "continuous",
  repeat_fmls_lnrs_args = TRUE,
  g_mode = "ratio_classification"
)
options(future.globals.maxSize = Inf) # if using lnr_rf_binary

# ---- Marginal LMTP fit (optional sanity check) ----
fit_marg <- fit_tmle_for_LMTP(
  ds,
  policy_seq = policy_seq,
  learners_Q = nadir::lnr_lm,
  learners_g_factory = nuis_density,
  outcome_link = "identity",
  repeat_lnrs = TRUE,
  method = "tmle"
)

fit_marg$psi
fit_marg$ci95
fit_marg$se

# ---- Heterogeneous LMTP effects by V ----
# V is a subset of W_cols (here just "V"), so we pass V = "V"
fit_het <- fit_lmtp_heterogeneous(
  ds,
  policy_seq = policy_seq,
  learners_Q = nadir::lnr_lm,
  learners_g_factory = nuis_density,
  V = "V",
  outcome_link = "identity",
  repeat_lnrs = TRUE,
  method = "tmle",
  stabilization = "naive"
)

fit_het$theta      # E[Y^d | V=1] and E[Y^d | V=2]
fit_het$ci95
fit_het$se
fit_het$p_v       # empirical subgroup proportions

```
